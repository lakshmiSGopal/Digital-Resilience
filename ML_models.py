# -*- coding: utf-8 -*-
"""event detection new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L_ezGIyHMCXhRk5K29VnxwNvVh4_h7ny
"""

#importing necessary libraries
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
import numpy as np
from sklearn.multiclass import OneVsRestClassifier
from sklearn.model_selection import RandomizedSearchCV
from sklearn.metrics import accuracy_score
import numpy as np
from sklearn import metrics
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
import nltk
import re
from nltk.corpus import stopwords
nltk.download('stopwords')
from sklearn.model_selection import learning_curve
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, classification_report

def clean_text(text):
    if isinstance(text, float):
        return ""  # Or any other suitable handling for missing/float values

    text = text.lower()
    text = re.sub(r"[^a-zA-Z0-9\s]", "", text)
    text = re.sub(r"\s+", " ", text)
    stop_words = set(stopwords.words("english"))
    return " ".join(word for word in text.split() if word not in stop_words)

def vec_tfidf(x):
    tfidf=TfidfVectorizer()
    x=tfidf.fit_transform(x)
    return x

def vec_encoding(y):
    encoder=LabelEncoder()
    y=enconder.fit_transform(y)
    return y

def loss_detect(predict,text):
    if predict[0]==1: #If aftermath is there then text is passed to loss detection model
        text=tfidf.transform([text])
        pred=svm_loss.predict(text).tolist()
    else:
        return "No aftermath detected"
    return pred

def prediction(text):
    text=tfidf.transform([text])
    predict=svm_event.predict(text).tolist()
    return predict

def train_event_model(xdtrain, ydtrain):
    svm_event = OneVsRestClassifier(SVC(kernel='rbf', gamma=0.1, C=1))  # SVC for event detection
    svm_event.fit(xdtrain, ydtrain)
    return svm_event

# Function to train event loss model
def train_loss_model(xetrain, yetrain):
    svm_loss = OneVsRestClassifier(SVC(C=1, gamma=0.001, kernel='linear'))  # SVC for event loss
    svm_loss.fit(xetrain, yetrain)
    return svm_loss

def score(model, xtest, ytest, name):
    # Predict using the model
    predictions = model.predict(xtest)

    # Calculate accuracy
    accuracy = accuracy_score(ytest, predictions)
    print(f"{name} Accuracy: {accuracy}")

    # Print the classification report
    print(f"Classification Report for {name}:")
    print(classification_report(ytest, predictions))

def main():
  #Importing data
  df_eventloss = pd.read_csv("test2.csv")
  df_eventloss=df_eventloss.dropna()
  df_detection=pd.read_csv("model.csv")
  df_detection=df_detection.dropna()
  # Converting text into vectors and applying label encoding
  xe = vec_tfidf(df_eventloss['sentence'])
  # Extracting labels for event loss dataset
  ye = encoder.fit_transform(df_eventloss['label'])
  # Apply TF-IDF to the detection dataset (if applicable)
  xd = vec_tfidf(df_detection['sentence'])
  # Extracting labels for detection dataset (already one-hot encoded)
  yd = df_detection.drop(columns=['sentence', 'label'])
  #Spliting data
  xdtrain,xdtest,ydtrain,ydtest=train_test_split(xd,yd,test_size=0.2)
  xetrain,xetest,yetrain,yetest=train_test_split(xe,ye,test_size=0.1)
  #Training model
  svm_event = train_event_model(xdtrain, ydtrain)
  svm_loss = train_loss_model(xetrain, yetrain)
  #Scoring
  score(svm_event, xdtest, ydtest, "Event Detection")
  score(svm_loss, xetest, yetest, "Event Loss")

main()